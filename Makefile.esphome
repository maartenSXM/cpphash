# This makefile attempts to regenerate esphome firmare based on
# generated file contents, not just based on timestamps.  
# It will skip esphome yaml generation when the yaml generated
# by cpptext is unchanged from a previous build.  In addition,
# It will skip running platformio to build the source generated 
# by esphome if the generated main.cpp is the same as the previous
# build.

# The including Makefile should include Makefile.cpptext,
# which in turn includes this file, Makefile.esphome

# The including Makefile should define ESP_INIT to an
# output of Makefile.cpptext (i.e. it is one of the generated
# files listed in CPT_GEN.

# The including Makefile should also define ESP_YAML to
# the name of the yaml file that this Makefile fragment should
# generate using yamlmerge.sh, for processing by esphome and
# platformio.

SHELL=/bin/bash

ifeq ($(shell which yq),)
  $(error "yq not found. Please install it")
endif

# ESP_INIT is the file to run yamlmerge.sh on so that esphome
# map keys (AKA esphome components) can be repeated.  Otherwise,
# the yaml spec requires that only one yaml map key, such as
# esphomes sensor: can exist.

ESP_INIT ?= espinit.yaml

# ESP_YAML is the output of cpptext/yamlmerge.sh which has
# all the esphome component definitions merged together to form
# legitimate yaml that esphome tools can parse.

ESP_YAML ?= esphome.yaml

ESP_BLDYAML   := $(CPT_BUILD_DIR)/$(ESP_INIT)
ESP_GENYAML   := $(CPT_BUILD_DIR)/$(ESP_YAML)
ESP_YAMLMERGE := $(CPT_HOME)/yamlmerge.sh -s -e

# Use content changes to dependencies instead of timestamps to trigger
# generation of esphome.yaml, main.cpp and the build firmware.elf.
# This eliminates a lot of unecessary builds.  This scheme works by
# only updating a .md5 file when the checksum of its corresponding file
# actually changes.  The rules trigger builds based on the md5 file
# timestamps, not the source file timestamps.

.SUFFIXES: .md5
.PHONY: all

# adds .md5 suffix to file names
md5 = $(addsuffix .md5,$1)$(eval ESP_MD5FILES += $(addsuffix .md5,$1))

# The md5 is calculated and stashed in CHECKSUM. If the  existing .md5
# file doesn't exist or its stored md5 is different, then CHECKSUM is
# placed in the .md5 file, which updates its timestamp.

%.md5: %
	@$(eval CHECKSUM := $(shell md5sum "$*"))			\
	  $(if $(filter-out $(shell cat "$@" 2>/dev/null),$(CHECKSUM)),	\
	    echo $(CHECKSUM) > "$@")

esphomeTgt: cppTgt $(ESP_GENYAML)

$(ESP_GENYAML): $(call md5,$(ESP_BLDYAML) $(ESP_DEPS))
	@printf "Makefile.esphome: $(<F:.md5=) changed.\n"
	$(ESP_YAMLMERGE) -o "$@" "$(<:.md5=)"
	cd "$(@D)" && esphome compile "$(@F)"
	
# When generating an esphome project, we need to do some extra stuff
# for secrets.yaml since esphome expects it to be in the same directory
# as the esphome yaml file.  That is, in $(CPT_BUILD_DIR). So 
# the build and clean targets are extended to handle that.

define ESP_BUILD_MORE
	@if [ "$(CPT_BUILD_DIR)" != "." -a -f "secrets.yaml" ]; then	    \
	  if [ -L "$(CPT_BUILD_DIR)/secrets.yaml" ]; then		    \
	    rm -f $(CPT_BUILD_DIR)/secrets.yaml;			    \
	  fi;								    \
	  echo "Makefile.esphome: linking $(CPT_BUILD_DIR)/secrets.yaml";   \
	  ln -s secrets.yaml $(CPT_BUILD_DIR)/secrets.yaml;		    \
	fi
endef

define CPT_CLEAN_MORE
	rm -f $(ESP_GENYAML)
	@if [ "$(CPT_BUILD_DIR)" != "." -a -f "secrets.yaml" ]; then	\
	  if [ -L "$(CPT_BUILD_DIR)/secrets.yaml" ]; then		\
	    echo "rm $(CPT_BUILD_DIR)/secrets.yaml";			\
	    rm -f $(CPT_BUILD_DIR)/secrets.yaml;			\
	  fi;								\
	fi
	rm -f $(sort $(ESP_MD5FILES))
endef

define print_defaults_rule
print-defaults:: cppTgt $(CPT_TMP_DIR)/$(1)
	@printf "Default values for $(1)\n"
	@$(CPT_CPP) -CC $(CPT_TMP_DIR)/$(1) |		\
		grep '^//#default' | sed 's/^../  /'
endef

$(foreach gen,$(patsubst ./%,%,$(CPT_GEN)),		\
    $(eval $(call print_defaults_rule,$(gen))))

# target "realclean" cleans .esphome from $(CPT_BUILD_DIR)

CPT_REALCLEAN_MORE := rm -rf $(CPT_BUILD_DIR)/.esphome \
			$(CPT_BUILD_DIR)/.gitignore

.PHONY: esphomeTgt print-defaults espBuild
.PRECIOUS: $(ESP_FIRMWARE)

